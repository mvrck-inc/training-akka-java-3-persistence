Webをはじめとした多くのアプリケーションを作成する際、非同期処理によって処理効率の向上を目指すことは今や当たり前になってきました。
この背景は、2005年以降一般市場向けのマルチコアCPUが出回るようになり、次第にシングルコアCPUに代わってマルチコアCPUが主流になるとともに、そのCPU一台あたりのコア数も増えてきたことがあります。
「マルチコアCPU上で動くマルチスレッド・アプリケーション」を効率よく、かつ堅牢につくる重要性が時代の流れとともに増してきたのです。
そしてマルチスレッド環境で処理を効率良く走らせようとすると、必然的に非同期処理を多用するようになります。

しかし非同期処理を多用したアプリケーションを堅牢に作ることは、以前から非常に難しく、現代でも難しい課題の一つです。
非同期処理を走らせるコードを書くと、コードレビューやユニットテストでは発見しづらい「不幸なタイミングが重なって起きるバグ」を埋め込んでしまうことがあり、
これらの落とし穴を回避することはいまでもプログラマにとって難度の高い仕事であると言えます。

ひと昔には「マルチスレッド環境での非同期処理は、必ず一流プログラマに任せなければならない」、
「マルチスレッドを駆使するリアルタイム・ゲームの開発者こそが本物のプログラマ」なんてことを言う人もいました。
今では非同期処理のためのツールが充実してきたこともあって、以前よりはハードルが下がっています。
そのぶん、より多くのプログラマが非同期処理を扱う機会が多くなっています。
非同期処理の落とし穴からプログラマを守るように作られたツールがたくさんあり、
JavaScriptのasync/await, JavaのCompletableFuture, KotlinのCoroutine, Goのgoroutine/channelなどがその代表格でしょう。

ツールが充実してきたと言っても、いまだに難しい種類の非同期処理もあります。
それは「マルチスレッド環境でのミュータブルオブジェクト管理」を伴う非同期処理です。
アプリケーション内部でのミュータブルオブジェクトは状態を表します。
このミュータブルオブジェクトが表す状態を、マルチスレッド環境で正しく管理するのが非常に難しいのです。

アプリケーション内の状態とはゲームであれば現在の得点かもしれませんし、eコマースであれば買い物かごかもしれません。
[トレーニングの第一回](https://github.com/mvrck-inc/training-akka-java-1-preparation)で触れたように、
伝統的な3層アーキテクチャ伝統的なWeb層・アプリケーション層・DB層を持つアプリケーションでは、アプリケーションの状態を全てDBに退避させることが一般的です。
状態を持つのはDBだけにし、アプリケーション層は「状態がない=ステートレス」に作ることがベスト・プラクティスでした。

なぜならWebアプリケーションのプロトコルであるHTTPがそうであるように、ステートレスな仕組みでは状態管理という非常に煩わしい課題から開放されます。
ステートレスはアプリケーションの保守コストを下げるベスト・プラクティスだと広く認識されているのです。それは障害復旧時の復元や、ノード間の状態の複製といった厄介な悩み事を忘れられることを意味します。

しかし、一切の状態をもたないアプリケーションはただのデータ通信パイプになってしまうので、伝統的な3層アーキテクチャではアプリケーションの状態を多くの場合DBに全て閉じ込めます。
そしてアプリケーション層での処理効率を上げるためのマルチスレッド非同期処理は、DB層のトランザクションによって排他制御されDBの状態を管理する、というのが通常の作り方でした。
この方法では、アプリケーションの成長とともにDB内のテーブルが増えてくると、排他制御の難度が上がっていきます。

一度の処理で2つ程度のテーブルを同時に更新する程度ならよいのですが、３つ、４つ、更に多数のテーブルと同時にテーブルを更新する場合は大変です。
当然同時更新の際に排他制御するテーブルが増えれば増えるほど、競合の頻度は上がり、ロックの解放待ちによってアプリケーションのパフォーマンスは低下します。
一方でDBのテーブルは小さく分割し正規化された状態をたもつのがベスト・プラクティスであり、非同期処理と正規化という2つの異なる方向性の設計をDBにおいて両立しなければなりません。

Akkaのアクターを用いれば異なる設計によって非同期処理を実現できます。DBにおけるトランザクションに頼るのではなく、Akka内部で用意されたメッセージキューによって非同期処理の排他制御を行います。
そしてAkkaのOSSメンテなを多数雇用するLightbend社が行ったベンチマークによると、1台のマシン上で毎秒5000万メッセージを送受信し、わずか1GBのヒープメモリの利用で250万ものアクターの生成を実現するという
パフォーマンスの良さを示しています。

このトレーニングではAkkaアクターを使った非同期処理の実装方法を学びます。Akkaアクターの裏側で動く仕組みは紹介しません。
裏側の仕組みについては:

- [CodeZine: Akkaで学ぶアクターモデル入門 第2回 アクターモデルは非同期処理におけるミュータブルオブジェクトの問題点をどう解決するのか](https://codezine.jp/article/detail/11888)
- [YouTube: Akka's Actor Model](https://www.youtube.com/watch?v=HONm6rOkqbU)

を御覧ください。
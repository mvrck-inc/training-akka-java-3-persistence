伝統的な3層アーキテクチャでは、多くの場合アプリケーションの状態をデータベース層に退避させるということは、第一回のトレーニングでも紹介しました。
データベース層はデータの最新の状態を保存し、アプリケーション層はそれをクエリによって取り出すことで自身をステートレスに保ち、状態管理の煩雑さを避けます。

- TODO: 3層アーキテクチャの画像

このようなアーキテクチャを採用した場合、あるデータベース内での変更履歴を追跡するにはどうすればよいでしょう？
これは特殊な要求ではなく、ビジネスを支える多くのアプリケーションで要求される機能です。

例えば文書管理アプリケーションで社内プロジェクトの情報を管理する場合、誰がどの時点でどんな内容が追記したのか確認できれば、
不明瞭な記述やチームでの合意事項に反する記述をした本人と話し合って訂正をしやすくなります。
eコマースサイトで、システムの不具合でキャンセルされたはずの注文が決済完了になる問題があったとします。あるいは配送開始から2週間以上経ったのに購入者宅にまだ商品が配送されていないかもしれません。
そんなときに顧客の注文の最新状態だけでなく、予約、決済完了、配送中、配送完了と、どの時点で誰が状態を更新したかという情報は、原因追跡に不可欠です。
データがビジネス上重要であればあるほど、往々にしてその変更履歴もまた重要で価値をもつものです。金融機関の取引履歴、GPSによる経路履歴、履歴が重要な例は枚挙に暇がありません。

- TODO: 文字だけ画像…金融機関の取引履歴、文書管理アプリケーションの文書変更履歴
- TODO: あるいは文書の変更履歴や金融機関の取引履歴を思わせる画像とか

リレーショナル・データベースで履歴を管理しようとする場合、[トリガーは代表的な手法](https://www.postgresql.org/docs/12/plpgsql-trigger.html#PLPGSQL-TRIGGER-AUDIT-EXAMPLE)です。
しかし、履歴テーブルは最新の状態を保存した別テーブルと同時に更新され、テーブル間はACIDでいう不可分性と一貫性を保つためトランザクションを利用する必要があります。
また履歴テーブルと最新の状態テーブルという組み合わせだけでなく、トレーニング第一回で見たように、注文テーブルと在庫テーブルのように異なる用途のテーブルの組み合わせでも不可分性と一貫性を保つためには、
更に多くのテーブル間にまたがってトランザクションを利用せねばならず、更新処理は複雑化しアプリケーションのパフォーマンスが落ちる一因にもなります。

- TODO: 不可分性と一貫性を保つの図 with 履歴

トリガー以外にも、MySQLの場合にはバイナリ形式で[テーブルの変更履歴](https://dev.mysql.com/doc/refman/5.6/ja/binary-log.html)を自動保存する機能がありますが、
履歴の解析をする際にはバイナリ形式のログファイルをダウンロードして解析用のコマンドを走らせる必要があります。
バイナリ形式のログは日常使う機能としての履歴調査よりは、緊急時の調査目的として用いるために適しているでしょう。

データベースにとってだけでなく、アプリケーション全体で履歴は重要です。よりリアルタイムで、よりアプリケーションが複雑化し状態の更新頻度が高くなる現代において、その重要性は増しています。
履歴の重要性を踏まえて、この第3回のトレーニングではAkkaアプリケーションにデータベースなどの永続化層を導入する設計パターンとして、イベント・ソーシングを紹介します。
イベント・ソーシングは履歴をデータ管理の中心に据え、かつ高い更新パフォーマンスを実現しうる設計パターンの一つです。

- TODO: イベント・ソーシングの図（データベース、イベント・ソーシングではより一般的には永続化層とも呼ばれる）

第2回のトレーニングですでにアクターを用いたアーキテクチャを紹介しましたが、データベースによる永続化機能はありませんでした。
もちろん、アクターを用いたアプリケーションでも変わらず永続化は重要です。
イベント・ソーシング設計パターンではデータ保存先はデータベース以外にKafkaなどのメッセージキューも含むため、より一般化して永続化層とよばれます。もちろんデータベースも永続仮想として使えます。
このパターンでは、多くのアプリケーションで重要なデータの変更履歴を、一連のデータ更新処理手順の中心にすえます。
ここからはその更新手順の詳細を説明しましょう。

まず、データの変更要求はメッセージとしてアクターに届けられます。
ここで思い出してほしいのは、アクターを用いたアプリケーションは、アクター同士がメッセージを送り合う設計で作成し、アクターの動作の起点は必ずアクターに届くメッセージということです。
イベント・ソーシングを採用する場合、アクターに届けられるメッセージはコマンドと呼ばれます。単なるメッセージではなくデータの書き込みコマンドという点を強調しています。
コマンドを受け取ったアクターは、コマンドをイベントと呼ばれる別のデータ構造に変換した後、永続化層のキューに挿入します。
アプリケーションで採用する永続化層がメッセージキューならばメッセージキューに、リレーショナル・データベースならキューの役割を果たすテーブルにINSERT命令のみを使ってレコードを挿入していくことになります。
注意すべき点ですが、キューに挿入するイベントは履歴データになるので、イベントの更新、削除（SQLならUPDATEとDELETE）は行いません。
履歴を更新・削除しては履歴を信頼できなくなるからです。CRUDという言葉を聞いたことがあれば、これはCRUDと比較してUとDが無いパターンだと言えます。

アクターはイベントを永続化キューに挿入し、それが完了するまで待ちます。挿入が完了したら、アクターは自身の内部状態にイベントを適用して状態を更新します。
挿入の完了を待つことで、アクターの内部状態は失敗したイベントによって不正に更新されることがありません。
そして永続化層にはアクターの内部状態は保存されず、あくまでイベントの履歴が挿入されていくのみです。

履歴の永続化はリレーショナル・データベースのトリガー機能を使っても実現できましたが、
イベント・ソーシングがそれと比べて優れているのは、リレーショナル・データベースのトランザクション管理の必要がなくなることです。
これはアプリケーション全体のパフォーマンス向上にも寄与する可能性があります。
もちろんアプリケーションのパフォーマンスはそう簡単に優劣をつけられるものではなく、本番環境に近い構成で全体計測及び個別コンポーネントの計測を行い、
また実際の利用パターンを考慮した負荷をかけなければ正しいパフォーマンスを計測することは出来ません。

永続化層への操作が挿入という唯一の操作に限られることは、その他のメリットがあります。
伝統的な3層アーキテクチャでは、通常アプリケーション層はステートレスに保ち、アプリケーションの内部状態のほとんどをデータベースに退避することを紹介しました。
この設計はアプリケーション層はシンプルに保てる一方、業務ロジックがデータベースへのクエリによって実現されがちになり、いわゆるトランザクション・スクリプトと呼ばれる構成になります。
トランザクション・スクリプト自体がアンチパターンと言うことはないのですが、気をつけないとアプリケーションの機能追加に伴い、いきおいデータベース層のソースコードが肥大化し複雑になる要因となります。
イベント・ソーシングではデータベース層のコードは挿入しか考えなくてよくなるため単純になります。
アプリケーションの業務ロジックをデータベースのクエリではなく、アクターの内部状態を保持するオンメモリのデータ構造に対する操作として表現できるので、
プログラミング言語の機能を生かしてよりより自然に業務ロジックを表現しやすくなります。

他の利点として、この設計パターンでは履歴がいつでも利用可能であることがあります。
これはリレーショナル・データベースのトリガー機能でも実現できていた利点ですが、
履歴が残ることで、監査のような用途にも使えますし、障害が起きたときのトラブルシューティングにも役立ちます。

イベント・ソーシングは耐障害性にも優れます。通常、アプリケーション層に内部状態を残すとプロセス自体やマシン自体が落ちたときに復旧が難しいのですが、
イベント・ソーシングでは永続化層のイベント履歴をリプレイすればアプリケーション層の内部状態を復元できるという特徴があります。
アプリケーション層をステートレスにする3層アーキテクチャでも、アプリケーション層の復旧が簡単という意味ではおなじでしたが、
イベント・ソーシングでは他の利点を実現しつつも復旧が楽であるという点に意味があります。

最後に、イベント・ソーシングはストリーム処理パイプラインと統合しやすいというメリットがあります。
永続化層にイベントが次々に挿入されていくという特徴はまさにストリームとして表現しやすいものであり、
ストリーム処理はアプリケーション内をリアルタイムかつ大量のデータが絶え間なく流れるという現在の大規模アプリケーションを構築するのになくてはならないものとなっています。

ここまで紹介してきたイベント・ソーシングですが、これは設計パターンであり、実装まで提供しているのはAkkaをふくめ僅かな数の（私が知る限りではAkkaが唯一の）ライブラリのみです。
自分でこの仕組みを実装するのは、いくらメリットが大きい設計パターンとはいえハードルが高いものです。
Akkaが提供する実装を使って、トレーニング課題の中でこのパターンのメリットを実感していきましょう。

参考文献: 
Chatwork
Martin Fowlerのトランザクションスクリプト
加藤純さんのスライド
MSDN - Reference 3: Introducing Event Sourcing　https://docs.microsoft.com/en-us/previous-versions/msp-n-p/jj591559(v=pandp.10)?redirectedfrom=MSDN
Events as first class citizen https://hackernoon.com/events-as-first-class-citizens-8633e8479493
[データベースアプリケーション開発を炎上させる負のスパイラル - 漢のコンピュータ道](http://nippondanji.blogspot.com/2013/11/blog-post.html)
https://www.postgresql.org/docs/12/plpgsql-trigger.html#PLPGSQL-TRIGGER-AUDIT-EXAMPLE